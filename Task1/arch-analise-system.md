# Планирование: анализ, идентификация проблем и поиск решений

## Анализ проблемных мест

| Проблема | Описание | Решение  | Приоритет  |
|---|---|---|---|
| Долгий синхронный запрос стоимости  |  расчёт стоимости занимает 2–30 минут; если он выполняется в синхронном/блокирующем режиме — запросы/заказы «зависают» | Добавить статус `PRICE_CALC_PENDING`. Это позволит проставлять статус, как только заказ взят на расчет, в API/онлайн-магазине сразу отвечать клиенту «заказ принят, расчёт в очереди». Когда заказ готов — переводить в `PRICE_CALCULATED`. Также можно будет отслеживать время между этими статусами \n - проработать ускорение расчёта (добавить предварительный/примерный расчет, проработать и оптимизировать алгоритмы)  | 1 - критично, нужно для наблюдаемости  |
| Отсутствие асинхронной оркестрации и управления задачами | нет механизма очередей задач уровня приложения (job workers, приоритеты, таймауты, retry, DLQ) | Перевести расчёт стоимости в асинхронную задачу (job) с подтверждением получения (ack)  | 1 - критично. Ключевая оптимизация системы  |
| Один инстанс приложения на один инстанс БД | нет отказоустойчивости, нет масштабирования на чтение; единственная точка отказа | - Добавить read-replicas для БД и репликацию / масштабирование   | 2 - важно. Но можно делать не в первую очередь  |
| Недостаточная горизонтальная масштабируемость MES вычислений | вычисления тяжёлые по CPU/mem; нельзя быстро нарастить мощность под пиковую нагрузку | Выделить вычисления расчёта стоимости в отдельный service / worker pool \n Создать отдельный worker-сервис C# (или microservice) который берет задачу, масштабируется независимо, поддерживаеет приоритеты очередей | 2 - целевое решение, с потенциальным перездом в kubernetes. Важно, но не первостепенно. |
| RabbitMQ: потенциальный узел перегрузки / отсутствие контрольно-защитных мер | возможны дубли/потеря сообщений, переполнения очередей, отсутствиут мониторинг очередей | - разные очереди для разных сегментов клиентов\n - добавить retry/deadletter очереди в каждый процесс, поддержать их обработку в MES \n - Организовать RabbitMQ в кластер  | 3 - при наличии мониторинга может выполняться силами SRE-сотрудников  |
| Плохая видимость состояния заказов для клиентов/операторов | пользователи жалуются, что «не получили заказ» — нет прозрачных уведомлений/статусов, нет SLA/контрольно-учётных событий | Добавить уведомления на email/SMS, отображать статусы в CRM, в личном кабинете и API  | 3 - повышение лояльности, не первостепенно  |
| UI-перформанс (MES dashboard) | первая страница долго загружается;\n фильтры/пагинация не помогли — возможные причины: тяжёлые DB-запросы, отсутствие индексов, отсутствие специализированного read-store (поиск, аналитика) | - Оптимизировать MES dashboard: read replica / materialized view / ElasticSearch \n - добавить кеш Redis для дашборда | 2 - важно, но можно отложить на второй этап, т.к. оптимизация обработки заказов критичнее  |
| Инфраструктурные ограничения (EC2 одиночные инстансы) | деплой «по одному инстансу на приложение», отсутствие контейнеризации/оркестрации и автоматического масштабирования | - перевести приложения в контейнеры, настроить auto-scaling для worker-подов, LoadBalancer'ы для фронтендов.  | 3 - пока системане готова к контейнерезации, заблокировано предыдущими этапами  |
| CI/CD и релизная дисциплина | ручной деплой на среды release/prod, ручное тестирование E2E в тестовом окружении; медленный фидбек по доратокам → долгие задержки релизов | - развивать автотестирование, покрыть критически-важные процессы \n - как появятся автотесты -  автоматизация deployment в среды release/prod  | 3 - повышение time-to-market  |
| Недостаточный SLO/SLAs и мониторинг  | нет метрик для time-to-price, нет алертов для растущего бэклога заказов | - Ввести статусы и уведомления для клиентов + отображать обратный отсчет, согласно установленным SLA для каждого статуса\n - Prometheus + Grafana + alertmanager (собирать метрики SLA заазов, загрузку очередей, состояние систем и их загруженность) | 1 - критично, нет наблюдаемости системы  |
| Управление приоритетами (B2B vs B2C) | все заказы поступают в одну очередь и обрабатываются одинаково — не разграничены приоритеты  | - Добавить приоритеты и SLA в очередь (B2B / VIP / B2C) \n - Ввести SLA/KPIs и договориться с бизнесом (time-to-price, допустимый процент опзданий по SLA)  | 3 - заблокировано предыдущими этапами по очередям  |
| Процессы и люди  | один DevOps; QA в ручном режиме; команда маленькая для объёма задач — риск узких мест по исполнению  | Найм / усиление команды:\n - 1 SRE/DevOps \n - 1–2 backend engineers (C#/Java)\n - 1 QA automation \n В приоритете SRE и QA-автоматизатор  | 1 - критично |

## Выводы

Система не готова к растущей нагрузке: узкие места — долгий синхронный расчёт стоимости в MES, монолитные/одноинстансные деплои (без горизонтального масштабирования), слабая наблюдаемость и «проблемы интеграции» через очередь (идемпотентность, дубли, SLA/таймауты). Это вызывает рост просрочек, потерю заказов и падение доверия клиентов и партнёров.

### Общий план

Систему нужно планомерно развивать в сторону асинхронной обработки задач. Асинхронные процессы разблокируют возможность горизонтального масштабирования. Как следствие - возрастет нагрузка на RabbitMQ, но и разблокируется возможнсть контейнерезации. В долгострочной перспективе система должна переехать в kubernetes с резервированием всех компонентов.

### Рекомендуемые меры (на ближащие 6 месяцев)

1. Асинхронность расчёта
    - главный источник задержек — длительный расчёт. Перевод в асинхронный режим даёт почти мгновенное уменьшение «зависших» заказов и позволит поставить очередь задач и мониторинг. Большой эффект при сравнительно небольшой сложности реализации (API + очередь + worker).

2. Мониторинг и алерты
    - нельзя управлять проблемой без данных. Быстрый выигрыш — видимость загруженности очереди, старейшие заказы и т.д. На первых порах, видимые мониторингом проблемы можно будет устранять хотя бы вручную, там где это возможно. Так же, без мониторинга не понятно, как и что масштабировать.

3. Идемпотентность / корреляция сообщений
    - уменьшит дубли заказов и конфликты при повторных сообщениях; важно для доверия внешних API-партнёров.

